%ESTIMATEMAP Apply Kalman filter on map.%   G = ESTIMATEMAP(G,NU,R,H) updates the map G by application of%   the extended Kalman filter (EKF). The function implements a%   stacked version of the EKF with the following input arguments:%   The stacked measurement Jacobian H of size n x p, where p is%   the number of measurements (which in turn is the number of%   observed features times their number of parameters), and n %   the size of the map state vector. The stacked p x 1 innova-%   tion vector NU, and the stacked p x p observation covariance%   matrix R.%%   See also SLAM, MEANWM.% v.1.0, Kai Arras, Nov. 2003, CAS-KTHfunction G = estimatemapLines(G,nu,R,H,matches_ID_G_L,roboPose,segs)if ~isempty(nu),      % get state vector and covariance    [x,C] = getstate(G);       % EKF    S = H*C*H' + R;    K = C*H'*inv(S);    x = x + K*nu;    C = C - K*H*C;    %uptating the start and stopp point for the infinit lines in the global    %map. Added by Bjørn S        myGx = get(G,'x');        %utMatch = matches_ID_G_L        if( matches_ID_G_L~= -1 )                for i=1:size(matches_ID_G_L,1)                                      newAngle=x(2*matches_ID_G_L(i,1)+2);            newRadius=x(2*matches_ID_G_L(i,1)+3);                                                  %local start'n'nstopp point update            hit=0;            for k=1:size(segs,2)                                if( segs(2,k) == matches_ID_G_L(i,2) )                    hit=k;                    %disp('This is wrong...multiple segs per line')                    break                end;            end;                         localPoints=0;            if(hit == 0)                disp('estimatemap: this sould not happen.. check the main for-loop');                continue;            end;                 %             roboPoseCart = [roboPose(1) roboPose(2) roboPose(1) roboPose(2)];%             roboAngle    = roboPose(3);%             rotMatrix    = [cos(roboAngle) -sin(roboAngle);sin(roboAngle)%             cos(roboAngle)];            roboPoseCart = [roboPose(1) roboPose(2)];            roboAngle    = roboPose(3);            rotMatrix    = [cos(roboAngle) -sin(roboAngle);sin(roboAngle) cos(roboAngle)];                    startPoint   = (rotMatrix*segs(13:14,hit))'+roboPoseCart;            endPoint     = (rotMatrix*segs(15:16,hit))'+roboPoseCart;                        startLocalPoint = [startPoint endPoint];%             startLocalPoint =roboPoseCart+segs(13:16,hit)';            oldAngleLocal   =segs(5,hit);%                              %rotate to y-axis            kvasiRotationMatrix=[sin(-oldAngleLocal-roboAngle) cos(-oldAngleLocal-roboAngle)];%            localPoints(1)=newRadius;            localPoints(2)=[kvasiRotationMatrix]*startLocalPoint(1:2)';%            localPoints(3)=newRadius;            localPoints(4)=[kvasiRotationMatrix]*startLocalPoint(3:4)'; %                                             %%updating the start and stopp points to the "infint-lines" in                        %%the global map            alphaRad = get(myGx{1,1+matches_ID_G_L(i,1)},'x');            startStoppPoints = get(myGx{1,1+matches_ID_G_L(i,1)},'ss');                        oldAngle = alphaRad(1);                                     ssPoints = 0;            for j=1:4:size(startStoppPoints,2)                             %rotate to y-axis                kvasiRotationMatrix=[sin(-oldAngle) cos(-oldAngle)];%                ssPoints(j)=newRadius;                ssPoints(j+1)=[kvasiRotationMatrix]*startStoppPoints(j:j+1)';%                ssPoints(j+2)=newRadius;                ssPoints(j+3)=[kvasiRotationMatrix]*startStoppPoints(j+2:j+3)';                                                        end;                                    if( numel(ssPoints) < 4 )                disp('estimatemap: Something strange here...');            elseif( numel(localPoints) < 4)                disp('estimatemap: Something strange....');                %loc = localPoints;            end;                                      ssPoints = [ssPoints localPoints];%             %thin out the start/stopp points.%             %4! = 4*3*2*1= 24 cases%             % a1,b1 = start point%             % a2,b2 = stop  point%             % 1)  -------a1----a2----b1-----b2---%             % 2) --------a1----a2----b2-----b1---%             % 3) --------a1----b1----a2-----b2---%             % 4) --------a1----b1----b2-----a2---%             % 5) --------a1----b2----a2-----b1---%             %)6) --------a1----b2----b1-----a2----            %             % etc.....%                                   %presort             for j=1:4:size(ssPoints,2)                if( ssPoints(j+1) < ssPoints(j+3) )                    tmp=ssPoints(j+1);                    ssPoints(j+1) = ssPoints(j+3);                    ssPoints(j+3) =tmp;                end;             end;                        %sort some more               [val,index]= sort( ssPoints( (2:4:size(ssPoints,2))), 'descend' );            for j=1:numel(index)                sortedPoints(j*4-3)= ssPoints( index(j)*4-3 ) ;                sortedPoints(j*4-2)= ssPoints( index(j)*4-2 ) ;                sortedPoints(j*4-1)= ssPoints( index(j)*4-1 ) ;                sortedPoints(j*4)  = ssPoints( index(j)*4 )   ;            end;           % ut = sortedPoints            %connect any overlapping points            j=5;            while( j < size(sortedPoints,2) )                                match=1;                bigger=0;                smaller=0;                                if( sortedPoints(j-4+1) == sortedPoints(j+1) )                                     if( sortedPoints(j-4+3) > sortedPoints(j+3) )                        bigger = sortedPoints(j-4+1);                        smaller = sortedPoints(j+3);                    else                        bigger = sortedPoints(j-4+1);                        smaller = sortedPoints(j-4+3);                    end;                                                    elseif( sortedPoints(j+1) > sortedPoints(j-4+3) && sortedPoints(j+3) >= sortedPoints(j-4+3) )                    bigger = sortedPoints(j-4+1);                    smaller = sortedPoints(j-4+3);                                    elseif( sortedPoints(j+1) >= sortedPoints(j-4+3) && sortedPoints(j+3) < sortedPoints(j-4+3) )                  bigger = sortedPoints(j-4+1);                  smaller  = sortedPoints(j+3);                                  elseif( sortedPoints(j+1) < sortedPoints(j-4+3) )                    % no change                    match=0;                else                    disp('etimatemap...hmmm');                    match=0;                end;                                if(match)                                       % disp('Matched a ssPoint');                                        if(j==5)                        if ( size(sortedPoints,2) > j+4 )                            sortedPoints = [0 bigger 0 smaller sortedPoints( (j+4):size(sortedPoints,2) )];                        else                            sortedPoints = [0 bigger 0 smaller];                        end;                    else                        if ( size(sortedPoints,2) > j+4 )                            sortedPoints = [sortedPoints(1:j-4-1) 0 bigger 0 smaller sortedPoints( (j+4):size(sortedPoints,2) )];                        else                            sortedPoints = [sortedPoints(1:j-4-1) 0 bigger 0 smaller];                        end;                    end;                                        j = j-4;                end;                                j=j+4;                            end;                 %rotate back to newAngel            sortedPoints(1:2:numel(sortedPoints))=newRadius;            rotMatrix = [cos(newAngle) -sin(newAngle);sin(newAngle) cos(newAngle)];            for j=1:4:size(sortedPoints,2)                                             sortedPoints(j:j+1)=[rotMatrix]*sortedPoints(j:j+1)';                sortedPoints(j+2:j+3)=[rotMatrix]*sortedPoints(j+2:j+3)';                   end;                         myGx{1,1+matches_ID_G_L(i,1)}=set( myGx{1,1+matches_ID_G_L(i,1)},'ss',sortedPoints);            %%adding the start and stopp points to the "infint-lines" from the local map                         %ut2 = sortedPoints          end;         end;    % put back updated start'n'stop points    G=set(G,'x',myGx);  % put back updated state vector and covariance    G = setstate(G,x,C);          if det(C) < 0,        disp('--> estimatemap: cov negative definite after!');    end;end;